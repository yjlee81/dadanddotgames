<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Sum! or Done!</title>

  <!-- iOS 모바일 최적화 -->
   
  <meta name="viewport" 
      content="width=375, height=812, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <style>
  :root {
    --background-color: #fafafa;
    --text-color: #333;
    --accent-color: #007AFF;
    --tile-color: #ffffff;
    --tile-hover-color: #f8f8f8;
    --tile-selected-color: #FFE884; 
    --font-family: -apple-system, BlinkMacSystemFont, 
                   "San Francisco", "Helvetica Neue", 
                   Helvetica, Arial, sans-serif;
  }

  html, body {
  margin: 0;
  padding: 0;
  /* 뷰포트 자체를 375 x 812로 강제 지정 */
  width: 375px;
  height: 812px;
  /* 스크롤이 생기지 않도록 숨기기 (필요시) */
  overflow: hidden;

  /* 혹은 폰트, 배경 등 기본값 */
  background-color: #fafafa;
  color: #333;
  font-family: -apple-system, BlinkMacSystemFont, 
               "San Francisco", "Helvetica Neue", sans-serif;

  /* 터치 하이라이트 해제 */
  -webkit-tap-highlight-color: transparent;

  /* [추가] 텍스트 선택 방지: 드래그 시 텍스트가 선택되지 않도록 */
  body, .board-container {
    user-select: none;
    -webkit-user-select: none; /* 크롬/사파리 */
    -moz-user-select: none;    /* 파이어폭스 */
    -ms-user-select: none;     /* 옛날 IE */
  }
}

  /* GNB */
  .gnb-lnb {
    position: fixed;
    top: 0; left: 0;
    width: 100%;
    height: 70px;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 20px;
    box-sizing: border-box;
    background-color: #1a1a1a;
    z-index: 9999;
  }
  .gnb-lnb .logo {
    font-size: 1.2rem;
    font-weight: 700;
    color: #fff;
    cursor: pointer;
  }
  .gnb-lnb .game-title {
    margin: 0;
    font-size: 1.4rem;
    font-weight: 600;
    color: #ffffff;
  }

  /* 정보 바 */
  #info-bar {
    margin-top: 80px; /* GNB 높이를 비우기 위해 */
    margin-bottom: 10px;
    font-size: 1.1rem;
    font-weight: bold;
    text-align: center; /* 중앙 정렬 (선택) */
  }

  /* 버튼 스타일 (Ripple 예시) */
  button {
    position: relative;
    overflow: hidden; /* Ripple이 넘치지 않도록 */
    padding: 8px 14px;
    margin: 5px 8px;
    font-size: 1rem;
    cursor: pointer;
    border: none;
    border-radius: 8px;
    background-color: var(--accent-color);
    color: #fff;
    transition: background-color 0.2s ease;
  }
  button:hover {
    background-color: #0080ff;
  }
  button:active {
    background-color: #005bb5;
  }
  /* Ripple 효과 */
  button .ripple {
    position: absolute;
    border-radius: 50%;
    background-color: rgba(255, 255, 255, 0.4);
    transform: scale(0);
    animation: ripple-animation 0.6s linear forwards;
    pointer-events: none;
  }
  @keyframes ripple-animation {
    to {
      transform: scale(2.5);
      opacity: 0;
    }
  }

  /* 게임 보드 */
  #game-board {
    border-collapse: separate;
    border-spacing: 8px;
    margin: 0 auto 20px auto; /* 가운데 정렬 */
    max-width: 90vw;
  }
  #game-board td {
    width: 44px;
    height: 44px;
    background-color: var(--tile-color);
    border-radius: 12px; 
    text-align: center;
    vertical-align: middle;
    font-size: 22px;
    font-weight: 600;
    color: #333;
    transition: background-color 0.2s ease,
                transform 0.15s ease,
                box-shadow 0.15s ease;
    cursor: pointer;
    position: relative;
  }
  #game-board td:hover {
    background-color: var(--tile-hover-color);
    box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
    transform: scale(1.02);
  }
  #game-board td:active {
    transform: scale(0.95);
    transition: transform 0.05s ease;
  }
  /* 선택된 타일 */
  #game-board td.selected {
    background-color: var(--tile-selected-color) !important;
    box-shadow: 0 3px 8px rgba(255, 232, 132, 0.6);
    transform: scale(1.05);
  }

  /* 실패 시 흔들기 */
  #game-board td.fail-line {
    animation: shake-fail 0.4s ease;
  }
  @keyframes shake-fail {
    0% { transform: translateX(0); }
    25% { transform: translateX(-4px); }
    50% { transform: translateX(4px); }
    75% { transform: translateX(-4px); }
    100% { transform: translateX(0); }
  }

  /* 성공 시 라인 */
  #game-board td.success-line {
    background-color: #90ee90 !important;
    box-shadow: 0 0 10px #32cd32 inset;
  }

  /* 제거 애니메이션 */
  #game-board td.removing {
    animation: success-remove 0.6s forwards ease;
  }
  @keyframes success-remove {
    0% {
      transform: scale(1.1);
      opacity: 1;
    }
    100% {
      transform: scale(0.7);
      opacity: 0;
    }
  }

  /* Floating Score 애니메이션 */
  .floating-score {
    position: absolute;
    left: 0;
    top: 0;
    font-size: 1.6rem;
    font-weight: bold;
    color: var(--accent-color);
    animation: floatScore 1.4s forwards cubic-bezier(0.25, 0.1, 0.25, 1.0);
    pointer-events: none;
    z-index: 999;
  }
  @keyframes floatScore {
    0% {
      transform: translate(-50%, 0) scale(1);
      opacity: 1;
    }
    100% {
      transform: translate(-50%, -60px) scale(1.3);
      opacity: 0;
    }
  }

  /* 반응형: 작은 화면에서 조금씩 축소 */
  @media (max-width: 600px) {
    .gnb-lnb {
      height: 56px;
      padding: 0 10px;
    }
    .game-title {
      font-size: 1.2rem;
    }
    button {
      font-size: 0.9rem;
      padding: 6px 10px;
      border-radius: 6px;
    }
    #game-board td {
      width: 36px;
      height: 36px;
      font-size: 18px;
      border-radius: 10px;
    }
  }

  /* === [추가] iOS 스타일 메시지/알림 등 UI 효과 === */
  .ios-toast {
    position: fixed;
    top: 80px;
    left: 50%;
    transform: translateX(-50%);
    background-color: #fff;
    color: #333;
    padding: 14px 20px;
    border-radius: 14px;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    font-size: 0.95rem;
    transition: all 0.3s ease;
    opacity: 0;
    pointer-events: none;
    z-index: 999999;
  }
  .ios-toast.show {
    opacity: 1;
    pointer-events: auto;
  }

  /* === [추가] 드래그 선택 시 강조 효과 === */
  .drag-select-highlight {
    background-color: rgba(255, 232, 132, 0.4) !important;
    box-shadow: 0 0 6px rgba(255,232,132, 0.8);
  }

  /* 성공/실패 시 좀 더 극적인 애니메이션 */
  #game-board td.success-line {
    background-color: #bdf0bd !important;
    box-shadow: 0 0 12px #53d153 inset;
    animation: success-pop 0.5s ease;
  }
  @keyframes success-pop {
    0%   { transform: scale(0.8); }
    100% { transform: scale(1.05); }
  }
  #game-board td.fail-line {
    animation: shake-fail 0.4s ease, fail-pulse 0.4s ease;
  }
  @keyframes fail-pulse {
    0%   { box-shadow: 0 0 0 #ff6a6a; }
    100% { box-shadow: 0 0 10px #ff6a6a inset; }
  }

  /* 새 라운드 시작 모달을 좀 더 세련되게 */
  #overlay-message {
    background-color: rgba(255,255,255,0.88);
    border-radius: 12px;
    padding: 16px;
    text-align: center;
    max-width: 300px;
  }
  #overlay-message button {
    margin-top: 12px;
  }
  </style>
  <script>
    const translations = {
      en: {
        title: "Sum! or Done!",
        round: "Round",
        sum: "Sum",
        score: "Score",
        time: "Time",
        noMore: "Done (Fail: -100 points)",
        hint: "Hint",
        startTile: "Start Tile",
        cancelSelection: "Selection Cancelled",
        success: "Success",
        fail: "Fail",
        hintMessage: "Select the tiles at both ends of the number",
        overlayClear: "Round Clear! Score=",
        overlayNext: "Proceed to the next round",
        overlayFail: "Combinations still exist! Score -100"
      },
      ko: {
        title: "합! or 결!",
        round: "라운드",
        sum: "합",
        score: "점수",
        time: "시간",
        noMore: "결 (실패시 -100점)",
        hint: "힌트",
        startTile: "시작칸",
        cancelSelection: "선택 취소",
        success: "성공",
        fail: "실패",
        hintMessage: "숫자 양끝 타일을 선택하세요",
        overlayClear: "라운드 클리어! 점수=",
        overlayNext: "다음 라운드 진행",
        overlayFail: "아직 조합이 남아있습니다! 점수 -100"
      },
      // 다른 언어 번역 추가
      ja: {
        title: "合計！または完了！",
        round: "ラウンド",
        sum: "合計",
        score: "スコア",
        time: "時間",
        noMore: "完了 (失敗時 -100点)",
        hint: "ヒント",
        startTile: "開始タイル",
        cancelSelection: "選択キャンセル",
        success: "成功",
        fail: "失敗",
        hintMessage: "数字の両端のタイルを選択してください",
        overlayClear: "ラウンドクリア！スコア=",
        overlayNext: "次のラウンドに進む",
        overlayFail: "まだ組み合わせが残っています！スコア -100"
      },
      zh: {
        title: "合！或完成！",
        round: "回合",
        sum: "合计",
        score: "得分",
        time: "时间",
        noMore: "完成 (失败时 -100分)",
        hint: "提示",
        startTile: "起始方块",
        cancelSelection: "取消选择",
        success: "成功",
        fail: "失败",
        hintMessage: "请选择数字两端的方块",
        overlayClear: "回合清除！得分=",
        overlayNext: "进行下一回合",
        overlayFail: "仍有组合存在！得分 -100"
      }
    };

    function updateLanguage(lang) {
      document.title = translations[lang].title;
      document.querySelector('.game-title').textContent = translations[lang].title;
      document.getElementById('round-label').textContent = translations[lang].round + " 1";
      document.getElementById('score-label').textContent = translations[lang].score + ":";
      document.getElementById('timer-label').textContent = translations[lang].time + ":";
      document.getElementById('no-more').textContent = translations[lang].noMore;
      document.getElementById('hint-btn').textContent = translations[lang].hint;
    }

    document.addEventListener('DOMContentLoaded', () => {
      const languageSelect = document.getElementById('language-select');
      languageSelect.addEventListener('change', (event) => {
        const selectedLang = event.target.value;
        updateLanguage(selectedLang);
      });

      // 초기 언어 설정
      updateLanguage(languageSelect.value);
    });

    // 버튼 Ripple 효과 예시 (선택)
  document.addEventListener("DOMContentLoaded", () => {
    const allButtons = document.querySelectorAll("button");
    allButtons.forEach(btn => {
      btn.addEventListener("click", (e) => {
        const circle = document.createElement("span");
        circle.classList.add("ripple");
        const rect = btn.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        circle.style.left = x + "px";
        circle.style.top = y + "px";

        btn.appendChild(circle);
        setTimeout(() => {
          circle.remove();
        }, 600);
      });
    });
  });
  </script>
</head>
<body>
  <!-- GNB 추가 -->
  <header class="gnb-lnb">
    <div class="left-group">
      <div id="logo" class="logo" onclick="window.location.href='/'" style="cursor: pointer;">
          D&D
        </div>
      <div class="divider"></div>
      <h2 class="game-title">Sum! or Done!</h2>
    </div>
    <div class="right-group">
      <div class="lang-dropdown">
        <select class="language-selector" id="language-select">
          <option value="en">EN</option>
          <option value="ko" selected>KR</option>
          <option value="ja">JP</option>
          <option value="zh">ZH</option>
        </select>
      </div>
    </div>
  </header>

<h1>Sum! or Done!</h1>

<!-- 상단 바: 라운드, 제시숫자, 점수, 타이머 -->
<div id="info-bar">
  <span id="round-label">Round 1</span> |
  <span>합:</span> <span id="target-number">10</span> |
  <span id="score-label">Score:</span> <span id="score">0</span>
  <span id="timer-label">Time:</span><span id="timer">00:00:00</span>
</div>

<!-- 버튼들 -->
<button id="no-more">결 (실패시 -100점)</button>
<button id="hint-btn">힌트</button>

<div id="status-bar"></div>

<!-- 보드 -->
<div class="board-container">
  <table id="game-board"></table>
</div>

<!-- 모달 오버레이 -->
<div id="overlay">
  <div id="overlay-message"></div>
</div>

  <script>
  /****************************************************************
   * 1. 전역 설정
   ****************************************************************/
  const BOARD_ROWS = 8;
  const BOARD_COLS = 8;
  const MIN_NUM = 1;
  const MAX_NUM = 9;

// 라운드 & 타겟
let currentRound = 1;
function getTargetForRound(round){
  return 10 + (round-1); // Round1=10, Round2=11,...
}
let targetSum = 10;
let totalScore = 0;  
// 2D array for board
let boardData = [];
// 첫 칸 선택
let startPos = null;
// 힌트 표시 중인 라인
let hintLinePositions = null;

// 타이머 관련 (한 번만 선언)
let timerInterval = null;  
let elapsedSeconds = 0;

/****************************************************************
 * 2. 라운드 초기화
 ****************************************************************/
function initRound(round=1){
  currentRound = round;
  targetSum = getTargetForRound(currentRound);

  // 보드 생성
  boardData = [];
  for(let r=0;r<BOARD_ROWS;r++){
    let rowArr=[];
    for(let c=0;c<BOARD_COLS;c++){
      let val= Math.floor(Math.random()*(MAX_NUM - MIN_NUM +1))+MIN_NUM;
      rowArr.push(val);
    }
    boardData.push(rowArr);
  }

  startPos=null;
  hintLinePositions=null;

  updateInfoBar();
  renderBoard();

  statusBarEl.textContent = 
    `Round ${currentRound} 시작! (Target=${targetSum}, 누적점수=${totalScore})`;
}

/****************************************************************
 * 3. DOM 참조
 ****************************************************************/
const roundLabelEl = document.getElementById("round-label");
const targetNumberEl = document.getElementById("target-number");
const scoreEl = document.getElementById("score");
const timerEl = document.getElementById("timer");

const boardEl = document.getElementById("game-board");
const noMoreBtn = document.getElementById("no-more");
const hintBtn = document.getElementById("hint-btn");

const statusBarEl = document.getElementById("status-bar");
const overlayEl = document.getElementById("overlay");
const overlayMsgEl = document.getElementById("overlay-message");

/****************************************************************
 * 4. 상단 정보 업데이트
 ****************************************************************/
function updateInfoBar(){
  roundLabelEl.textContent = `Round ${currentRound}`;
  targetNumberEl.textContent = targetSum;
  scoreEl.textContent = totalScore;
}

/****************************************************************
 * 5. 보드 렌더링
 ****************************************************************/
function renderBoard(){
  boardEl.innerHTML="";
  for(let r=0;r<BOARD_ROWS;r++){
    let tr = document.createElement("tr");
    for(let c=0;c<BOARD_COLS;c++){
      let td=document.createElement("td");
      let val= boardData[r][c];
      if(val===null){
        td.textContent="";
        td.classList.add("hidden-tile");
      } else {
        td.textContent=val;
      }

      // 클릭 이벤트
      td.addEventListener("click", ()=> onTileClick(r,c));

      // 시작칸 강조
      if(startPos && startPos[0]===r && startPos[1]===c){
        td.classList.add("selected");
      }

      tr.appendChild(td);
    }
    boardEl.appendChild(tr);
  }

  // 힌트 라인이 있으면 다시 표시
  if(hintLinePositions){
    markLine(hintLinePositions, "hint-line");
  }
}

/****************************************************************
 * 6. 타일 클릭 로직
 ****************************************************************/
function onTileClick(r,c){
  // 첫 클릭
  if(!startPos){
    startPos=[r,c];
    statusBarEl.textContent=`시작칸: (${r},${c}) val=${
      boardData[r][c]===null?0:boardData[r][c]
    }`;
    renderBoard();
    return;
  }

  // 같은 칸 클릭->취소
  if(startPos[0]===r && startPos[1]===c){
    startPos=null;
    statusBarEl.textContent="선택 취소";
    renderBoard();
    return;
  }

  // 두 번째 클릭
  const endPos=[r,c];
  checkLine(startPos,endPos);

  startPos=null;
  renderBoard();
}

/****************************************************************
 * 7. 라인 검사
 ****************************************************************/
function checkLine(start,end){
  const linePositions = getLinePositions(start,end);
  if(!linePositions){
    statusBarEl.textContent="가로/세로/대각 일렬 아님!";
    return;
  }

  // 힌트 표시 중이면 해제
  if(hintLinePositions){
    markLine(hintLinePositions,null,"hint-line");
    hintLinePositions=null;
  }

  // sumVal: 실제 숫자합, gapCount: null칸
  let sumVal=0;
  let gapCount=0;
  for(const [rr,cc] of linePositions){
    if(boardData[rr][cc]===null){
      gapCount++;
    } else {
      sumVal+= boardData[rr][cc];
    }
  }
  let length = linePositions.length;

  // 합이 targetSum?
  if(sumVal===targetSum){
    // 점수 계산
    let gapBonus = gapCount*10;
    let lengthBonus= (length>=3)?(length-2)*5:0;
    let addScore= sumVal + gapBonus + lengthBonus;

    markLine(linePositions,"success-line");
    statusBarEl.textContent=
      `성공! (합=${sumVal}, gap=${gapCount}, length=${length}) => +${addScore}`;

    totalScore+= addScore;
    updateInfoBar();

    showFloatingScore(`+${addScore}`, end[0], end[1]);

    setTimeout(()=>{
      removeLineTiles(linePositions);
    },600);

  } else {
    // 실패
    statusBarEl.textContent= `실패! (합=${sumVal}, 목표=${targetSum})`;
    markLine(linePositions,"fail-line");
    setTimeout(()=>{
      markLine(linePositions,null,"fail-line");
    },600);

    // 타깃 점수만큼 감점
    totalScore = Math.max(0, totalScore - targetSum);
    updateInfoBar();

    // 점수 차감 효과 표시
    showFloatingScore(`-${targetSum}`, end[0], end[1], true);
  }
}

/** 일렬(가로/세로/대각) or null */
function getLinePositions([r1,c1],[r2,c2]){
  let rd=r2-r1, cd=c2-c1;
  if(rd===0 && cd===0)return null;
  if(!(rd===0||cd===0||Math.abs(rd)===Math.abs(cd)))return null;

  function gcd(a,b){return b===0?a:gcd(b,a%b);}
  let g= gcd(Math.abs(rd),Math.abs(cd));
  let stepR= rd/g, stepC= cd/g;

  let pos=[];
  let curR=r1,curC=c1;
  pos.push([curR,curC]);

  let steps = Math.max(Math.abs(rd),Math.abs(cd));
  for(let i=0;i<steps;i++){
    curR+=stepR; curC+=stepC;
    if(curR<0||curR>=BOARD_ROWS||curC<0||curC>=BOARD_COLS)return null;
    pos.push([curR,curC]);
  }
  return pos;
}

/** 특정 라인에 클래스 부여/제거 */
function markLine(positions, addClass=null, removeClass=null){
  let trList=boardEl.querySelectorAll("tr");
  positions.forEach(([r,c])=>{
    let td= trList[r].querySelectorAll("td")[c];
    if(removeClass){
      td.classList.remove(removeClass);
    }
    if(addClass){
      td.classList.add(addClass);
    }
  });
}

/** 타일 제거 */
function removeLineTiles(linePositions){
  let trList=boardEl.querySelectorAll("tr");
  for(const [r,c] of linePositions){
    let td=trList[r].querySelectorAll("td")[c];
    td.classList.remove("success-line");
    td.classList.add("removing");
  }
  setTimeout(()=>{
    for(const [r,c] of linePositions){
      boardData[r][c]=null;
    }
    renderBoard();
  },600);
}

/****************************************************************
 * 8. "결" 버튼
 ****************************************************************/
noMoreBtn.addEventListener("click", () => {
  let found = findAllPossibleLines();
  if (found.length > 0) {
    // 실패 -> -100
    totalScore = Math.max(0, totalScore - 100);
    updateInfoBar();
    showOverlay(`아직 조합이 남아있습니다!<br>점수 -100`);
  } else {
    // 라운드 클리어 -> 다음 라운드
    totalScore += 100; // 성공 시 +100점
    updateInfoBar();
    showOverlay(`Round ${currentRound} 클리어!<br>Score=${totalScore}<br>다음 라운드 진행`);
  }
});

/** 남은 라인 찾기 (합만 비교) */
function findAllPossibleLines(){
  let results=[];
  for(let r=0;r<BOARD_ROWS;r++){
    for(let c=0;c<BOARD_COLS;c++){
      for(let dr=-1;dr<=1;dr++){
        for(let dc=-1;dc<=1;dc++){
          if(dr===0 && dc===0) continue;
          let linePos=[[r,c]];
          let sumVal= boardData[r][c]===null?0:boardData[r][c];
          let nr=r,nc=c;
          for(let step=1;step<8;step++){
            nr+=dr;nc+=dc;
            if(nr<0||nr>=BOARD_ROWS||nc<0||nc>=BOARD_COLS) break;
            sumVal+= (boardData[nr][nc]===null?0:boardData[nr][nc]);
            linePos.push([nr,nc]);
            if(sumVal===targetSum){
              results.push([...linePos]);
            }
          }
        }
      }
    }
  }
  return results;
}

/****************************************************************
 * 9. Floating Score
 ****************************************************************/
function showFloatingScore(txt, r, c, isPenalty = false) {
  const trList = boardEl.querySelectorAll("tr");
  const td = trList[r].querySelectorAll("td")[c];
  let rect = td.getBoundingClientRect();

  let floatEl = document.createElement("div");
  floatEl.classList.add("floating-score");
  floatEl.textContent = txt;
  floatEl.style.color = isPenalty ? "#ff0000" : "#0000ff"; // 감점 시 빨간색, 점수 추가 시 파란색
  document.body.appendChild(floatEl);

  let x = rect.left + rect.width / 2;
  let y = rect.top + rect.height / 2;
  floatEl.style.left = x + "px";
  floatEl.style.top = y + "px";

  setTimeout(() => {
    if (floatEl.parentNode) {
      floatEl.parentNode.removeChild(floatEl);
    }
  }, 1000);
}

/****************************************************************
 * 10. 힌트 버튼
 ****************************************************************/
hintBtn.addEventListener("click", onHintClick);

function onHintClick(isInitialHint = false) {
  let lines = findAllPossibleLines();
  if (lines.length === 0) {
    statusBarEl.textContent = "힌트: 남은 조합이 없습니다!";
    return;
  }
  // 기존 힌트 있으면 제거
  if (hintLinePositions) {
    markLine(hintLinePositions, null, "hint-line");
    hintLinePositions = null;
  }
  // 하나 선택 (예: 첫 번째)
  let picked = lines[0];
  hintLinePositions = picked;
  // 표시
  markLine(picked, "hint-line");
  statusBarEl.textContent = "힌트 표시!";

  // 힌트 사용 시 점수 차감
  if (!isInitialHint) {
    let sumVal = 0;
    let gapCount = 0;
    for (const [rr, cc] of picked) {
      if (boardData[rr][cc] === null) {
        gapCount++;
      } else {
        sumVal += boardData[rr][cc];
      }
    }
    let length = picked.length;
    let gapBonus = gapCount * 10;
    let lengthBonus = (length >= 3) ? (length - 2) * 5 : 0;
    let hintPenalty = sumVal + gapBonus + lengthBonus;

    totalScore = Math.max(0, totalScore - hintPenalty);
    updateInfoBar();

    // 점수 차감 효과 표시
    showFloatingScore(`-${hintPenalty}`, picked[0][0], picked[0][1], true);
  } else {
    // 초기 힌트 메시지 표시
    showInitialHintMessage(picked[0][0], picked[0][1]);
  }
}

function showInitialHintMessage(r, c) {
  const trList = boardEl.querySelectorAll("tr");
  const td = trList[r].querySelectorAll("td")[c];
  let rect = td.getBoundingClientRect();

  let hintMessageEl = document.createElement("div");
  hintMessageEl.classList.add("hint-message");
  hintMessageEl.textContent = "숫자 양끝 타일을 선택하세요";
  document.body.appendChild(hintMessageEl);

  let x = rect.left + rect.width / 2;
  let y = rect.top - 30; // 30px 위쪽에 표시
  hintMessageEl.style.left = x + "px";
  hintMessageEl.style.top = y + "px";

  // 클릭 시 페이드 아웃
  boardEl.addEventListener("click", function fadeOutHint() {
    hintMessageEl.style.transition = "opacity 0.5s ease";
    hintMessageEl.style.opacity = "0";
    setTimeout(() => {
      if (hintMessageEl.parentNode) {
        hintMessageEl.parentNode.removeChild(hintMessageEl);
      }
    }, 500);
    boardEl.removeEventListener("click", fadeOutHint);
  });
}

/****************************************************************
 * 11. 모달
 ****************************************************************/
function showOverlay(msg){
  overlayMsgEl.innerHTML= msg + "<br><button onclick='closeOverlay()'>확인</button>";
  overlayEl.style.display="flex";
}
function closeOverlay(){
  overlayEl.style.display="none";
  let lines= findAllPossibleLines();
  if(lines.length===0){
    // 라운드 클리어 -> 다음 라운드
    currentRound++;
    initRound(currentRound);
  }
}

/****************************************************************
 * 12. 타이머(HH:MM:SS)
 ****************************************************************/
function startTimer(){
  timerInterval = setInterval(()=>{
    elapsedSeconds++;
    timerEl.textContent = formatTime(elapsedSeconds);
  },1000);
}
function formatTime(sec){
  let h = Math.floor(sec/3600);
  let m = Math.floor((sec%3600)/60);
  let s = sec%60;
  let hh = (h<10)?"0"+h:h;
  let mm = (m<10)?"0"+m:m;
  let ss = (s<10)?"0"+s:s;
  return `${hh}:${mm}:${ss}`;
}

/****************************************************************
 * 13. 게임 시작
 ****************************************************************/
window.onload=()=>{
  // 타이머 시작(중복 선언 없이 한번만)
  startTimer();

  // 첫 라운드 시작
  initRound(1);

  // 첫 번째 힌트 자동 표시
  onHintClick(true);
};

// === [추가] iOS 느낌의 간결 메시지 함수 ===
function showIOSToastMessage(msg, duration = 1200) {
  const toast = document.createElement('div');
  toast.classList.add('ios-toast');
  toast.textContent = msg;
  document.body.appendChild(toast);

  // 잠시 후 등장
  setTimeout(() => {
    toast.classList.add('show');
  }, 50);

  // 지정 시간 뒤 자동 제거
  setTimeout(() => {
    toast.classList.remove('show');
    setTimeout(() => {
      if (toast.parentNode) {
        toast.parentNode.removeChild(toast);
      }
    }, 300);
  }, duration);
}

// === [추가] 드래그/터치 슬라이드로 타일 선택 기능 ===
let isDragging = false;
function startDragSelect(r, c) {
  isDragging = true;
  dragPositions = [[r, c]];
  dragDirection = null; // 'row', 'col', 'diag' 등
  startPos = null;
  dragDirection = null;
  startPos = [r, c];
  markTileAsDragSelected(r, c);
}

function continueDragSelect(r, c) {
  if (!isDragging) return;

  // 이미 동일 칸이면 무시
  let lastPos = dragPositions[dragPositions.length - 1];
  if (lastPos[0] === r && lastPos[1] === c) {
    return;
  }

  // 최초로 방향을 결정해야 하는 시점(두 번째 칸)
  if (dragDirection === null) {
    const dr = r - startPos[0];
    const dc = c - startPos[1];
    // 가로(동일 행) / 세로(동일 열) / 대각( |dr| == |dc| ) 체크
    if (dr === 0 && dc !== 0) {
      dragDirection = 'row';   // 같은 행
    } else if (dc === 0 && dr !== 0) {
      dragDirection = 'col';   // 같은 열
    } else if (Math.abs(dr) === Math.abs(dc)) {
      dragDirection = 'diag';  // 대각선
    } else {
      // 방향이 확정되지 않으면 중단
      return;
    }
  }

  // 지금 클릭/터치한 (r,c)가 dragDirection에 맞는지 확인
  if (!isInSameLine(startPos, [r, c], dragDirection)) {
    return; // 일렬이 아니면 무시
  }

  // 기존 하이라이트 지우고
  clearDragSelection();
  // 새로 (startPos)부터 (r,c)까지 라인 계산 후 하이라이트
  const linePositions = getLinePositions(startPos, [r, c]);
  if (!linePositions) return;
  dragPositions = linePositions; 
  markDragSelection(linePositions);
}

function stopDragSelect() {
  if (!isDragging) return;
  isDragging = false;

  // 드래그로 선택된 그룹의 합산 체크
  if (!dragPositions || dragPositions.length < 2) {
    clearDragSelection();
  } else {
    checkDragSelectedTiles();
  }
}

/* [추가] 방향 검사 로직(가로/세로/대각) */
function isInSameLine([r1, c1], [r2, c2], direction) {
  if (direction === 'row') {
    return (r1 === r2);
  } else if (direction === 'col') {
    return (c1 === c2);
  } else if (direction === 'diag') {
    return (Math.abs(r2 - r1) === Math.abs(c2 - c1));
  }
  return false;
}

/* [추가] 드래그 중 라인 강조 */
function markDragSelection(linePositions) {
  const trList = boardEl.querySelectorAll("tr");
  linePositions.forEach(([r, c])=>{
    const td = trList[r].querySelectorAll("td")[c];
    td.classList.add('drag-select-highlight');
  });
}

/* [수정] 드래그 선택 해제 */
function clearDragSelection() {
  const trList = boardEl.querySelectorAll("tr");
  dragPositions.forEach(([r, c]) => {
    const td = trList[r].querySelectorAll("td")[c];
    td.classList.remove('drag-select-highlight');
  });
  dragPositions = [];
}

/* [수정] 드래그된 타일들 합산 체크 */
function checkDragSelectedTiles() {
  const start = dragPositions[0];
  const end = dragPositions[dragPositions.length - 1];
  clearDragSelection(); 
  checkLine(start, end);
}

// === [수정] 보드 렌더링 시 mousedown, mousemove, mouseup(또는 터치 이벤트) 추가 ===
function renderBoard(){
  boardEl.innerHTML = "";
  for(let r=0; r<BOARD_ROWS; r++){
    let tr = document.createElement("tr");
    for(let c=0; c<BOARD_COLS; c++){
      let td = document.createElement("td");
      // 기존 코드...
      td.textContent = boardData[r][c] === null ? "" : boardData[r][c];

      // 기존 td.addEventListener("click", ...) ...
      td.addEventListener("mousedown", () => startDragSelect(r, c));
      td.addEventListener("mousemove", () => continueDragSelect(r, c));
      td.addEventListener("mouseup", () => stopDragSelect());
      // 터치 환경도 처리
      td.addEventListener("touchstart", () => startDragSelect(r, c), {passive: true});
      td.addEventListener("touchmove", (e) => {
        const touch = e.touches[0];
        const targetEl = document.elementFromPoint(touch.clientX, touch.clientY);
        if (targetEl && targetEl.tagName === 'TD') {
          const rowIndex = [...boardEl.querySelectorAll('tr')].indexOf(targetEl.parentNode);
          const colIndex = [...targetEl.parentNode.children].indexOf(targetEl);
          continueDragSelect(rowIndex, colIndex);
        }
      }, {passive: true});
      td.addEventListener("touchend", () => stopDragSelect());

      tr.appendChild(td);
    }
    boardEl.appendChild(tr);
  }
  if (hintLinePositions) {
    markLine(hintLinePositions, "hint-line");
  }
  // 기존 코드...
}

// === [수정] checkLine 함수에 성공/실패 시 iOS 스타일 메시지 표시 추가 ===
function checkLine(start, end) {
  const linePositions = getLinePositions(start, end);
  if(!linePositions) {
    statusBarEl.textContent = "가로/세로/대각 일렬 아님!";
    showIOSToastMessage("잘못된 경로!");
    return;
  }
  if(hintLinePositions) {
    markLine(hintLinePositions, null, "hint-line");
    hintLinePositions = null;
  }
  let sumVal=0, gapCount=0;
  for(const [rr,cc] of linePositions){
    if(boardData[rr][cc]===null){
      gapCount++;
    } else {
      sumVal+= boardData[rr][cc];
    }
  }
  let length = linePositions.length;

  if(sumVal===targetSum){
    // 성공
    markLine(linePositions, "success-line");
    let gapBonus = gapCount*10, lengthBonus = (length>=3)?(length-2)*5:0;
    let addScore= sumVal + gapBonus + lengthBonus;
    totalScore += addScore;
    updateInfoBar();
    showIOSToastMessage(`성공! +${addScore}점 획득`);

    setTimeout(()=> {
      removeLineTiles(linePositions);
    }, 600);
  } else {
    // 실패
    markLine(linePositions, "fail-line");
    showIOSToastMessage("실패!", 1500);
    setTimeout(() => {
      markLine(linePositions, null, "fail-line");
    }, 600);
  }
}

// === [수정] noMoreBtn 클릭 시 iOS 스타일 메시지 + 모달 표시
noMoreBtn.addEventListener("click", () => {
  let found = findAllPossibleLines();
  if(found.length > 0) {
    totalScore = Math.max(0, totalScore - 100);
    updateInfoBar();
    showIOSToastMessage("아직 조합이 남아있습니다! -100점");
    showOverlay(`아직 조합이 남아있습니다!<br>점수 -100점`);
  } else {
    totalScore += 100;
    updateInfoBar();
    showIOSToastMessage(`Round ${currentRound} 클리어! +100점`);
    showOverlay(`Round ${currentRound} 클리어!<br>Score=${totalScore}<br>다음 라운드 진행`);
  }
});

// === [수정] 모달 열릴 때 라운드 정보 iOS 스타일로 멋지게 보이도록
function showOverlay(msg){
  overlayMsgEl.innerHTML = 
    `<div style="font-size:1.2rem; font-weight:600; margin-bottom:8px;">
        라운드 정보
     </div>` 
     + msg 
     + "<br><button onclick='closeOverlay()'>확인</button>";
  overlayEl.style.display = "flex";
}
</script>

</body>
</html>